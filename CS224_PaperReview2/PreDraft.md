# p1
读标题

# p2
这篇paper关注的是静态分析工具中的假阳性问题，也就是工具报告某处代码可能存在bug但实际上没有，其实也就是误报
可以看一个例子，在第二行代码这里，file变量已经被检测是不是false了，但是静态分析器在第七行这里还是会认为file可能是false而报出一个warning
这类问题就是这篇论文希望解决的

# p3
作者发现了这样一种现象 就是静态分析器的用户 也就是我们一般的开发者 一般会通过修改代码来避免假阳性或者说这样的误报
还是刚才的例子，我们可能会通过显式的，直接的增加这样一个if语句让静态分析器知道这个file接下来不可能是false

# p4
基于这样一种观察或者说基于开发者拥有的这种修改代码的能力，我们可以提出一种简单的解决方案，还是file这个例子，我们将代码中的语句进行语法上的抽象，再将用于避免误报的修改后的代码进行抽象，这样我们就可以利用左边这个模板template或者说pattern，去遍历整个项目，一旦发现符合的代码实例，我们就用右边的template去进行替换重写，从而避免假阳性

# p5
ok 所以这就是这篇论文提出方法的思路 
首先 静态分析器的用户在发现某种假阳性以后去编写对应的template 就像刚刚展示的那样 这样的好处在于每个使用者都相当于一个contributor 使得每个用户都能针对自己遇到的问题对软件进行定制化

# p6
接着有了template 我们就会在整个项目中找到符合的代码实例并生成重写后的文件 这里的优势在于开发者不必真的改变项目代码 而是生成新的文件 保证了项目代码不必因假阳性问题而改变 因为由于代码可读性等原因 我们一般是不希望因为没用的warning改变代码的

# p7
最后我们把重写后的代码丢给静态分析器 所以可以看到这套方法与静态分析器本身是独立的 不必去修改分析器的算法或者代码实现 这点其实很重要 因为针对某种假阳性而去修改这很麻烦

# p8
作者针对三种语言五种分析器进行了实验
当然 就像前面说的这个方法不是全自动的 它需要用户编写template 所以这里作者在这五种分析器的github上搜索与假阳性有关的pr和issue，然后手动编写了九个template 针对这九种假阳性进行实验

# p9
最后的结果就是这样 我们主要关注红框中的内容
引入的额外运行时间可以忽略不计
绝大部分情况下可以消灭掉所有目标假阳性问题

# p10
最后就是这篇工作的一些可以改进的点
首先编写template是有学习曲线在的
第二点就是目前template是纯基于语法的 忽略了类型信息